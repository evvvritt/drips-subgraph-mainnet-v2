type FundingProject @entity {
  id: ID! # the NFT Registry Address (ERC-721 address)
  projectName: String
  projectOwner: Bytes! # address
  dripsTokenTemplate: Bytes! # addess of ERC-721 contract used
  blockTimestampCreated: BigInt!
  daiCollected: BigInt!
  daiSplit: BigInt!
  tokenTypes: [TokenType!]! @derivedFrom(field: "fundingProject")
  tokens: [Token!]! @derivedFrom(field: "fundingProject")
  ipfsHash: String
}

type TokenType @entity {
  id: ID! # the ERC-721 address + "-" + the tokenID
  tokenRegistryAddress: Bytes!
  tokenTypeId: BigInt!
  streaming: Boolean!
  limit: BigInt!
  minAmtPerSec: BigInt!
  fundingProject: FundingProject!
  ipfsHash: String
  currentTotalAmtPerSec: BigInt!
  currentTotalGiven: BigInt!
}

type Token @entity {
  id: ID! # the tokenId
  tokenId: BigInt!
  tokenRegistryAddress: Bytes!
  tokenType: TokenType!
  tokenReceiver: Bytes! # address
  rank: BigInt!
  amtPerSec: BigInt!
  giveAmt: BigInt!
  fundingProject: FundingProject!
}

type DripsConfig @entity {
  id: ID! # user
  dripsEntries: [DripsEntry!]! @derivedFrom(field: "dripsConfig")
  balance: BigInt!
}

type DripsEntry @entity {
  id: ID! # user + "-" + receiver + ["-" + account if present]
  user: Bytes! # the user's address
  dripsConfig: DripsConfig!
  isAccountDrip: Boolean! # true if this is an account Drip, false otherwise
  account: BigInt! # the user's account
  receiver: Bytes! # the receiver's address
  amtPerSec: BigInt!
  endTime: BigInt!
}

type SplitsConfig @entity {
  id: ID! # user
  receiverAddresses: [Bytes!]!
  splitsEntries: [SplitsEntry!]! @derivedFrom(field: "splitsConfig")
}

type SplitsEntry @entity {
  id: ID! # user + "-" + receiver
  splitsConfig: SplitsConfig!
  sender: Bytes! # the user's address
  receiver: Bytes! # the receiver's address
  weight: BigInt!
}
